diff --git a/python/BUILD.bazel b/python/BUILD.bazel
--- a/python/BUILD.bazel
+++ b/python/BUILD.bazel
@@ -8,6 +8,7 @@ go_library(
     srcs = [
         "configure.go",
         "file_parser.go",
+        "file_parser_windows.go",
         "fix.go",
         "generate.go",
         "kinds.go",
@@ -41,8 +42,12 @@ go_library(
         "@com_github_emirpasic_gods//lists/singlylinkedlist",
         "@com_github_emirpasic_gods//sets/treeset",
         "@com_github_emirpasic_gods//utils",
-        "@com_github_smacker_go_tree_sitter//:go-tree-sitter",
-        "@com_github_smacker_go_tree_sitter//python",
         "@org_golang_x_sync//errgroup",
-    ],
+    ] + select({
+        "@platforms//os:windows": [],
+        "//conditions:default": [
+            "@com_github_smacker_go_tree_sitter//:go-tree-sitter",
+            "@com_github_smacker_go_tree_sitter//python",
+        ],
+    }),
 )
diff --git a/MODULE.bazel b/MODULE.bazel
--- a/MODULE.bazel
+++ b/MODULE.bazel
@@ -8,6 +8,7 @@ bazel_dep(name = "rules_python", version = "0.18.0")
 bazel_dep(name = "rules_go", version = "0.59.0", repo_name = "io_bazel_rules_go")
 bazel_dep(name = "gazelle", version = "0.47.0", repo_name = "bazel_gazelle")
 bazel_dep(name = "rules_cc", version = "0.0.16")
+bazel_dep(name = "platforms", version = "1.0.0")
 
 local_path_override(
     module_name = "rules_python",
diff --git a/python/file_parser.go b/python/file_parser.go
--- a/python/file_parser.go
+++ b/python/file_parser.go
@@ -1,3 +1,5 @@
+//go:build !windows
+
 // Copyright 2023 The Bazel Authors. All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
diff --git a/python/resolve.go b/python/resolve.go
--- a/python/resolve.go
+++ b/python/resolve.go
@@ -90,7 +90,8 @@ func importSpecFromSrc(pythonProjectRoot, bzlPkg, src string) resolve.ImportSpec {
 	if relPythonPkgDir == "." {
 		relPythonPkgDir = ""
 	}
-	pythonPkg := strings.ReplaceAll(relPythonPkgDir, "/", ".")
+	pythonPkg := strings.ReplaceAll(relPythonPkgDir, "\\", "/")
+	pythonPkg = strings.ReplaceAll(pythonPkg, "/", ".")
 	filename := filepath.Base(src)
 	if filename == pyLibraryEntrypointFilename {
 		if pythonPkg != "" {
diff --git a/python/file_parser_windows.go b/python/file_parser_windows.go
new file mode 100644
--- /dev/null
+++ b/python/file_parser_windows.go
@@ -0,0 +1,206 @@
+//go:build windows
+
+package python
+
+import (
+	"context"
+	"os"
+	"path/filepath"
+	"regexp"
+	"strings"
+)
+
+var (
+	importStatementRe = regexp.MustCompile(`^\s*import\s+(.+)$`)
+	fromImportRe      = regexp.MustCompile(`^\s*from\s+([A-Za-z0-9_\.]+)\s+import\s+(.+)$`)
+)
+
+type ParserOutput struct {
+	FileName string
+	Modules  []Module
+	Comments []Comment
+	HasMain  bool
+}
+
+type FileParser struct {
+	code        []byte
+	relFilepath string
+	output      ParserOutput
+}
+
+func NewFileParser() *FileParser {
+	return &FileParser{}
+}
+
+func (p *FileParser) SetCodeAndFile(code []byte, relPackagePath, filename string) {
+	p.code = code
+	p.relFilepath = filepath.Join(relPackagePath, filename)
+	p.output.FileName = filename
+}
+
+func (p *FileParser) Parse(ctx context.Context) (*ParserOutput, error) {
+	lines := strings.Split(string(p.code), "\n")
+	p.output.HasMain = hasMainBlock(string(p.code))
+
+	inTypeCheckingBlock := false
+	typeCheckingIndent := -1
+
+	for i, rawLine := range lines {
+		if err := ctx.Err(); err != nil {
+			return nil, err
+		}
+
+		lineNo := uint32(i + 1)
+		trimmed := strings.TrimSpace(rawLine)
+		indent := leadingIndent(rawLine)
+
+		if inTypeCheckingBlock && trimmed != "" && indent <= typeCheckingIndent {
+			inTypeCheckingBlock = false
+			typeCheckingIndent = -1
+		}
+		if trimmed == "if TYPE_CHECKING:" || trimmed == "if typing.TYPE_CHECKING:" {
+			inTypeCheckingBlock = true
+			typeCheckingIndent = indent
+		}
+
+		if strings.HasPrefix(trimmed, "#") {
+			p.output.Comments = append(p.output.Comments, Comment(trimmed))
+			continue
+		}
+
+		if m := importStatementRe.FindStringSubmatch(rawLine); len(m) == 2 {
+			for _, item := range splitCommaList(m[1]) {
+				mod := normalizeImportItem(item)
+				if mod == "" || strings.HasPrefix(mod, ".") {
+					continue
+				}
+				p.output.Modules = append(p.output.Modules, Module{
+					Name:             mod,
+					LineNumber:       lineNo,
+					Filepath:         p.relFilepath,
+					TypeCheckingOnly: inTypeCheckingBlock,
+				})
+			}
+			continue
+		}
+
+		if m := fromImportRe.FindStringSubmatch(rawLine); len(m) == 3 {
+			from := cleanImportString(m[1])
+			resolvedFrom := resolveImportFromModule(from, p.relFilepath)
+			if resolvedFrom == "" {
+				continue
+			}
+			// Match upstream behavior on common `from x import y` statements.
+			p.output.Modules = append(p.output.Modules, Module{
+				Name:             resolvedFrom,
+				LineNumber:       lineNo,
+				Filepath:         p.relFilepath,
+				TypeCheckingOnly: inTypeCheckingBlock,
+			})
+		}
+	}
+
+	return &p.output, nil
+}
+
+func (p *FileParser) ParseFile(ctx context.Context, repoRoot, relPackagePath, filename string) (*ParserOutput, error) {
+	code, err := os.ReadFile(filepath.Join(repoRoot, relPackagePath, filename))
+	if err != nil {
+		return nil, err
+	}
+	p.SetCodeAndFile(code, relPackagePath, filename)
+	return p.Parse(ctx)
+}
+
+func hasMainBlock(code string) bool {
+	return strings.Contains(code, `if __name__ == "__main__":`) ||
+		strings.Contains(code, `if "__main__" == __name__:`) ||
+		strings.Contains(code, "if '__main__' == __name__:") ||
+		strings.Contains(code, "if __name__ == '__main__':")
+}
+
+func leadingIndent(line string) int {
+	n := 0
+	for _, r := range line {
+		if r == ' ' || r == '\t' {
+			n++
+			continue
+		}
+		break
+	}
+	return n
+}
+
+func splitCommaList(value string) []string {
+	value = strings.TrimSpace(value)
+	value = strings.TrimPrefix(value, "(")
+	value = strings.TrimSuffix(value, ")")
+	value = stripInlineComment(value)
+	if value == "" {
+		return nil
+	}
+	return strings.Split(value, ",")
+}
+
+func stripInlineComment(value string) string {
+	if idx := strings.Index(value, "#"); idx >= 0 {
+		return value[:idx]
+	}
+	return value
+}
+
+func normalizeImportItem(item string) string {
+	item = strings.TrimSpace(item)
+	if item == "" {
+		return ""
+	}
+	if strings.Contains(item, " as ") {
+		item = strings.SplitN(item, " as ", 2)[0]
+	}
+	item = cleanImportString(item)
+	return item
+}
+
+func resolveImportFromModule(from, relFilepath string) string {
+	from = strings.TrimSpace(from)
+	if from == "" {
+		return ""
+	}
+	if !strings.HasPrefix(from, ".") {
+		return from
+	}
+
+	pkgDir := filepath.ToSlash(filepath.Dir(relFilepath))
+	pkgParts := []string{}
+	if pkgDir != "." && pkgDir != "" {
+		pkgParts = strings.Split(pkgDir, "/")
+	}
+
+	dotCount := 0
+	for dotCount < len(from) && from[dotCount] == '.' {
+		dotCount++
+	}
+	remainder := strings.TrimPrefix(from, strings.Repeat(".", dotCount))
+
+	ascend := dotCount - 1
+	if ascend < 0 {
+		ascend = 0
+	}
+	if ascend > len(pkgParts) {
+		return ""
+	}
+	baseParts := pkgParts[:len(pkgParts)-ascend]
+	if remainder != "" {
+		baseParts = append(baseParts, strings.Split(remainder, ".")...)
+	}
+	return strings.Join(baseParts, ".")
+}
+
+func cleanImportString(s string) string {
+	s = strings.ReplaceAll(s, "\r\n", "")
+	s = strings.ReplaceAll(s, "\\", "")
+	s = strings.ReplaceAll(s, " ", "")
+	s = strings.ReplaceAll(s, "\n", "")
+	s = strings.ReplaceAll(s, "\t", "")
+	return strings.TrimSpace(s)
+}
